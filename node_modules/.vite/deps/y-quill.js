import {
  compareRelativePositions,
  createAbsolutePositionFromRelativePosition,
  createRelativePositionFromJSON,
  createRelativePositionFromTypeIndex
} from "./chunk-APUQXYXC.js";
import "./chunk-2TUXWMP5.js";

// node_modules/y-quill/src/y-quill.js
var normQuillDelta = (delta) => {
  if (delta.length > 0) {
    const d = delta[delta.length - 1];
    const insert = d.insert;
    if (d.attributes === void 0 && insert !== void 0 && insert.slice(-1) === "\n") {
      delta = delta.slice();
      let ins = insert.slice(0, -1);
      while (ins.slice(-1) === "\n") {
        ins = ins.slice(0, -1);
      }
      delta[delta.length - 1] = { insert: ins };
      if (ins.length === 0) {
        delta.pop();
      }
      return delta;
    }
  }
  return delta;
};
var updateCursor = (quillCursors, aw, clientId, doc, type) => {
  try {
    if (aw && aw.cursor && clientId !== doc.clientID) {
      const user = aw.user || {};
      const color = user.color || "#ffa500";
      const name = user.name || `User: ${clientId}`;
      quillCursors.createCursor(clientId.toString(), name, color);
      const anchor = createAbsolutePositionFromRelativePosition(createRelativePositionFromJSON(aw.cursor.anchor), doc);
      const head = createAbsolutePositionFromRelativePosition(createRelativePositionFromJSON(aw.cursor.head), doc);
      if (anchor && head && anchor.type === type) {
        quillCursors.moveCursor(clientId.toString(), { index: anchor.index, length: head.index - anchor.index });
      }
    } else {
      quillCursors.removeCursor(clientId.toString());
    }
  } catch (err) {
    console.error(err);
  }
};
var QuillBinding = class {
  /**
   * @param {Y.Text} type
   * @param {any} quill
   * @param {Awareness} [awareness]
   */
  constructor(type, quill, awareness) {
    const doc = (
      /** @type {Y.Doc} */
      type.doc
    );
    this.type = type;
    this.doc = doc;
    this.quill = quill;
    const quillCursors = quill.getModule("cursors") || null;
    this.quillCursors = quillCursors;
    this._negatedUsedFormats = {};
    this.awareness = awareness;
    this._awarenessChange = ({ added, removed, updated }) => {
      const states = (
        /** @type {Awareness} */
        awareness.getStates()
      );
      added.forEach((id) => {
        updateCursor(quillCursors, states.get(id), id, doc, type);
      });
      updated.forEach((id) => {
        updateCursor(quillCursors, states.get(id), id, doc, type);
      });
      removed.forEach((id) => {
        quillCursors.removeCursor(id.toString());
      });
    };
    this._typeObserver = (event) => {
      if (event.transaction.origin !== this) {
        const eventDelta = event.delta;
        const delta = [];
        for (let i = 0; i < eventDelta.length; i++) {
          const d = eventDelta[i];
          if (d.insert !== void 0) {
            delta.push(Object.assign({}, d, { attributes: Object.assign({}, this._negatedUsedFormats, d.attributes || {}) }));
          } else {
            delta.push(d);
          }
        }
        quill.updateContents(delta, this);
      }
    };
    type.observe(this._typeObserver);
    this._quillObserver = (eventType, delta, state, origin) => {
      if (delta && delta.ops) {
        const ops = delta.ops;
        ops.forEach((op) => {
          if (op.attributes !== void 0) {
            for (const key in op.attributes) {
              if (this._negatedUsedFormats[key] === void 0) {
                this._negatedUsedFormats[key] = false;
              }
            }
          }
        });
        if (origin !== this) {
          doc.transact(() => {
            type.applyDelta(ops);
          }, this);
        }
      }
      if (awareness && quillCursors) {
        const sel = quill.getSelection();
        const aw = (
          /** @type {any} */
          awareness.getLocalState()
        );
        if (sel === null) {
          if (awareness.getLocalState() !== null) {
            awareness.setLocalStateField(
              "cursor",
              /** @type {any} */
              null
            );
          }
        } else {
          const anchor = createRelativePositionFromTypeIndex(type, sel.index);
          const head = createRelativePositionFromTypeIndex(type, sel.index + sel.length);
          if (!aw || !aw.cursor || !compareRelativePositions(anchor, aw.cursor.anchor) || !compareRelativePositions(head, aw.cursor.head)) {
            awareness.setLocalStateField("cursor", {
              anchor,
              head
            });
          }
        }
        awareness.getStates().forEach((aw2, clientId) => {
          updateCursor(quillCursors, aw2, clientId, doc, type);
        });
      }
    };
    quill.on("editor-change", this._quillObserver);
    quill.setContents(type.toDelta(), this);
    if (quillCursors !== null && awareness) {
      awareness.getStates().forEach((aw, clientId) => {
        updateCursor(quillCursors, aw, clientId, doc, type);
      });
      awareness.on("change", this._awarenessChange);
    }
  }
  destroy() {
    this.type.unobserve(this._typeObserver);
    this.quill.off("editor-change", this._quillObserver);
    if (this.awareness) {
      this.awareness.off("change", this._awarenessChange);
    }
  }
};
export {
  QuillBinding,
  normQuillDelta
};
//# sourceMappingURL=y-quill.js.map
